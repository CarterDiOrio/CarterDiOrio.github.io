{"version":3,"file":"component---src-templates-project-tsx-content-file-path-src-projects-camera-calibration-mdx-fb34563db9fee17b6084.js","mappings":"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","sources":["webpack://portfolio/./src/projects/camera-calibration.mdx","webpack://portfolio/./src/templates/project.tsx","webpack://portfolio/./src/components/table-of-contents.tsx","webpack://portfolio/./src/templates/project.module.css"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nimport {YouTube} from 'mdx-embed';\nimport {Divider} from 'theme-ui';\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    a: \"a\",\n    span: \"span\",\n    h2: \"h2\",\n    p: \"p\",\n    h3: \"h3\",\n    img: \"img\",\n    ol: \"ol\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.h1, {\n    id: \"analysis-of-fiducial-markers-and-camera-calibration\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#analysis-of-fiducial-markers-and-camera-calibration\",\n    \"aria-label\": \"analysis of fiducial markers and camera calibration permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Analysis of Fiducial Markers and Camera Calibration\"), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(Divider), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"800px\",\n      margin: \"auto\"\n    }\n  }, React.createElement(\"video\", {\n    autoPlay: true,\n    loop: true,\n    muted: true,\n    playsInline: true,\n    controls: true,\n    style: {\n      maxHeight: \"100%\",\n      maxWidth: \"100%\"\n    }\n  }, React.createElement(\"source\", {\n    src: \"/project.mp4\",\n    type: \"video/mp4\"\n  }))), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(Divider), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"fiducial-analysis\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#fiducial-analysis\",\n    \"aria-label\": \"fiducial analysis permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Fiducial Analysis\"), \"\\n\", React.createElement(_components.p, null, \"Github repository: \", React.createElement(_components.a, {\n    href: \"https://github.com/CarterDiOrio/FiducialMarkers\"\n  }, \"https://github.com/CarterDiOrio/FiducialMarkers\")), \"\\n\", React.createElement(_components.p, null, \"The original aim of of the project was to find the best method to detect an April tag using a Intel Realsense D435i camera. To evaluate whether one approach was better or not we needed a method\\nto evaluate the accuracy and precision of the fiducial and detection method combo.\"), \"\\n\", React.createElement(_components.h3, {\n    id: \"experimental-setup\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#experimental-setup\",\n    \"aria-label\": \"experimental setup permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Experimental Setup\"), \"\\n\", React.createElement(_components.p, null, \"To provide a ground truth transform between the camera and the tag for accuracy evaluation I used a Vicon optical tracking system. Since  our system has a small workspace it can measure position with an accuracy\\non the order of tens of microns.\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"800px\",\n      margin: \"auto\"\n    }\n  }, React.createElement(_components.p, null, React.createElement(_components.img, {\n    src: \"/vicon.jpg\",\n    alt: \"Image\"\n  }), \" \")), \"\\n\", React.createElement(_components.p, null, \"Tracking markers were then mounted to both the camera and the fiducial. This setup still does not directly give the ground truth transform. It gives us the transform between\\nthe markers attached to the camera (the hand) and the markers attached to the fiducial (the mount). To get a measurement of T_camera_fiducial from the Vicon we need to calibrate\\ntwo more transforms: the camera relative to the hand (T_hand_eye) and the fiducial relative to the mount (T_mount_fiducial). Knowing these two transforms completes the loop and establishes\\na ground truth estimate as shown below with the vicon as the world frame.\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"800px\",\n      margin: \"auto\"\n    }\n  }, React.createElement(_components.p, null, React.createElement(_components.img, {\n    src: \"/handeyegraph.png\",\n    alt: \"Image\"\n  }), \" \")), \"\\n\", React.createElement(_components.p, null, \"One major issue with this is that if we perform the calibration with a chessboard in the mount, then disassemble the mount to put the tag we want to evaluate in it, the calibration\\nis now invalid. Instead of paper tags that have to be swapped, an non-emissive paper like e-ink display can be used to display the tags. Using a lower level library to access the display\\nwe can exactly control how each fiducial is rendered, this ensures the T_mount_fiducial\\ntransform is transferable since we can render each calibration pattern or fiducial such that their origins are all in the same location. An added benefit is it also removes the additional position\\nerror that results from trying to repeat the same trajectory with each tag since for each position all the tags can be displayed on the display automatically.\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"800px\",\n      margin: \"auto\",\n      display: \"flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\"\n    }\n  }, React.createElement(\"video\", {\n    autoPlay: true,\n    loop: true,\n    muted: true,\n    playsInline: true,\n    controls: true,\n    style: {\n      maxHeight: \"400px\"\n    }\n  }, React.createElement(\"source\", {\n    src: \"/eink_testing_comp.mp4\",\n    type: \"video/mp4\"\n  }))), \"\\n\", React.createElement(_components.p, null, \"At its core the optimal calibration must minimize the reprojection error of all features as shown in the equation below, where every fiducial feature X has a corresponding image feature y, and p() is the\\nprojection function. Using a dense (26x26) chessboard as the calibration pattern I performed nonlinear optimization and the result was a 0.33 mean pixel reprojection error and a 0.25 millimeter mean translational error\\nof the extrinsics.\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"240px\",\n      margin: \"auto\",\n      background: \"white\",\n      \"justify-content\": \"center\"\n    }\n  }, React.createElement(_components.p, null, React.createElement(_components.img, {\n    src: \"/equation.png\",\n    alt: \"Image\"\n  }), \" \")), \"\\n\", React.createElement(_components.h3, {\n    id: \"precision-results\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#precision-results\",\n    \"aria-label\": \"precision results permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Precision Results\"), \"\\n\", React.createElement(_components.p, null, \"For each of the three fiducials under test, Chessboards, April tags, and ArUco markers, I assessed their accuracy over increasing distance and varied orientations.\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"800px\",\n      margin: \"auto\",\n      background: \"white\",\n      \"justify-content\": \"center\"\n    }\n  }, React.createElement(_components.p, null, React.createElement(_components.img, {\n    src: \"/chessboard_results.png\",\n    alt: \"Image\"\n  }), \" \")), \"\\n\", React.createElement(_components.p, null, \"Starting off with the chessboard above. Each chessboard is denoted by its number of squares and then the size of each square in millimeters. The sizes happen to be these non-whole numbers because they need to align with\\nthe nearest whole number of pixels on the eink display. For my experiment setup the dominant factor in the accuracy of the chessboard is the number of squares. Each \\\"band\\\" of square sizes are perfectly seperated\\nfrom each other in this plot and within each band the precision increases with square size. This confirms the common knowledge of more and larger corners is better, and that the number of corners should be increased\\ntill diminishing or negative returns.\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"1000px\",\n      margin: \"auto\",\n      background: \"white\",\n      display: \"flex\",\n      justifyContent: \"center\"\n    }\n  }, React.createElement(\"img\", {\n    src: \"/april_results.png\",\n    alt: \"April Results\",\n    style: {\n      maxWidth: \"50%\",\n      height: \"auto\",\n      marginRight: \"10px\"\n    }\n  }), React.createElement(\"img\", {\n    src: \"/aruco_results.png\",\n    alt: \"Aruco Results\",\n    style: {\n      maxWidth: \"50%\",\n      height: \"auto\"\n    }\n  })), \"\\n\", React.createElement(_components.p, null, \"Above on the left and right we have the April tag and ArUco results respectively. The April tag results have a significant outlier and I left it in to show that, at least in my usage, sometimes the April tag\\nlibrary produces significant outliers and that needs to be taken into account. However in their best case with both tags at 75 millimeters the April tags have better precision\\nwith 0.04, 0.04, 0.14 millimeters of standard deviation on the XYZ axes compared to 0.05, 0.05, and 0.17 millimeters of standard deviation on the ArUco markers. These results are close enough that it could be\\nargued it is within margin of error, but the best advice I could give is to benchmark it for your specific scenario. For example, I noticed the April tag detector works better on with the e-ink display (it has slight\\nglare) than the ArUco detector does.\"), \"\\n\", React.createElement(_components.h3, {\n    id: \"conclusion\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#conclusion\",\n    \"aria-label\": \"conclusion permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Conclusion\"), \"\\n\", React.createElement(_components.p, null, \"Planar fiducials like chessboards, April tags, and ArUco markers, can be very precise depending on your needs. With larger tags and a limited workspace you can expect sub-millimeter std deviations\\non all three axes with deviations getting as low as ~0.05mm, ~0.05mm, ~0.17mm on the XYZ axes respectively. Even if your workspace falls outside\\nthis definition, it has been shown that the precision scales linearly over distance within reasonable workspace and tag orientation envelope. However\\nyou can expect a large dropoff in precision and detection suddenly at further distances according to the April Tag 2 and ArUco papers. Some of this dropoff is attributed\\nto effects like feature detection noise increasing non linearly with the distance to the feature.\"), \"\\n\", React.createElement(_components.p, null, \"It is of note that accuracy is extremely difficult to test empirically and it is why there is no \\\"Accuracy Results\\\" section. Most major fiducial papers, even those claiming high accuracy like Rune Tags,\\nuse synthetically generated images for their experimental accuracy validation. These are careful simulations, but a method does not exist to empirically evaluate it on\\nyour specific camera setup. This is because you need the ground truth transform between the camera's center of projection and the tag. The tag's world position\\ncan either be surveyed or measured in a variety of ways, but the camera's center cannot be directly measured. It needs to be estimated using information from the camera itself,\\nand as far as I could find an extrinsic calibration method does not exist that gives sufficient accuracy and precision guarantees to meaningfully measure the accuracy of the tags.\\nEmpirically measuring the accuracy of tags is getting further into the area of serious metrology and statistics than the realm of typical computer vision and any further work needs\\nto treat it as such.\"), \"\\n\", React.createElement(_components.p, null, \"I also did not cover the rotational precision because planar fiducial markers also need to deal with a orientation ambiguity that exists in planar PnP (See [2]).\\nThis effects all standard planner patterns including chessboards but to a lesser extent. Solutions to this vary as covered by [2], but include modifications to the tag, averaging, filtering, and tracking. However,\\nignoring this effect, it scales linearly like the translational error within a reasonable workspace.\"), \"\\n\", React.createElement(_components.p, null, \"I did not have the time or setup required to explore this fully, but for future work, if you could prove that the relationship is extrapolatable back to the normal case it might be possible to use a camera that has significantly\\nhigher resolution to perform the extrinsic calibration then set it to a significantly lower resolution and move the tag far enough away that the tags error becomes the dominating factor. The one issue with this\\nis that tags are quite robust to lower resolutions. As shown in the chart below, I measured the std deviation of a stationary 75mm April tag at half a meter while continually decreasing the resolution by scailing the image\\ndown with the X axis being the percentage of 1080p. The reason I resorted to scailing is because most cameras (like the Realsense I was using) only have a few fixed resolutions they can operate at and it is not enough to get a good line fit. To make sure I was not\\nexaggerating the tags effectiveness by introducing interpolated information due to downscailing from a higher resolution I repeated the test but started at 720p and that is shown in orange and it matches the 1080p results. This is a great result\\nfor the tags, but it means this thrust of future research would require a camera that could go up to a significantly higher resolution.\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"600px\",\n      margin: \"auto\",\n      background: \"white\",\n      \"justify-content\": \"center\"\n    }\n  }, React.createElement(_components.p, null, React.createElement(_components.img, {\n    src: \"/april_tag_resolution.png\",\n    alt: \"Image\"\n  }), \" \")), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(Divider), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"mrcal\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#mrcal\",\n    \"aria-label\": \"mrcal permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"MrCal\"), \"\\n\", React.createElement(_components.p, null, \"Github repository: \", React.createElement(_components.a, {\n    href: \"https://github.com/CarterDiOrio/mrcal_ros\"\n  }, \"https://github.com/CarterDiOrio/mrcal_ros\")), \"\\n\", React.createElement(_components.p, null, \"Although it's challenging to empirically measure, one of the most critical factors affecting the accuracy of your tag's position measurements is your camera's intrinsic parameters. There's no substitute for using a robust framework and dedicating the effort to achieve precise calibration.\\nOne of the best open source frameworks that attempts to give statistical feedback and guarantees is MrCal [3] developed by NASA's JPL. MrCal's\\ndocuments and tutorial explains all of its analyses in detail, but I will give a short example about how it can approve even a well behaved lens as motivation. The plots in this section are from MrCal, which also serves as the source of all background information. For this example, I used approximately 400 images of a dense chessboard (26x26) as the calibration data\"), \"\\n\", React.createElement(_components.p, null, \"The Intel RealSense D435i's color lens does not come with distortion coefficients (see https://github.com/IntelRealSense/librealsense/issues/8325 and https://github.com/IntelRealSense/librealsense/issues/1430). Intel's\\nopinion is that it reduces about 1px of reprojection error at the extremess, and at first glance, the lens appears to be well-behaved. However, when we use a pinhole model and examine the reprojection error residuals from calibration, we observe clustering in the residual magnitudes, as shown below. Clustering of this kind indicates lens distortion, assuming other factors like rolling shutter have been accounted for. Since our chessboard corner detection error is roughly normally distributed, a fully modeled lens should also yield normally distributed residual errors in both magnitude and direction, which should appear as noise\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"600px\",\n      margin: \"auto\",\n      background: \"white\",\n      \"justify-content\": \"center\"\n    }\n  }, React.createElement(_components.p, null, React.createElement(_components.img, {\n    src: \"/pinhole_magnitudes.png\",\n    alt: \"Image\"\n  }), \" \")), \"\\n\", React.createElement(_components.p, null, \"As for the residual directions, shown below for the pinhole model, they also exhibit a high degree of clustering. It's important to emphasize that this isn't due to a poor calibration but rather to modeling error. No amount of refining the pinhole parameters will resolve this issue because the D435i's color lens simply isn't a pinhole lens. Even if you don't require the enhanced accuracy provided by a more complex model, MrCal offers tools to help you make an informed decision.\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"600px\",\n      margin: \"auto\",\n      background: \"white\",\n      \"justify-content\": \"center\"\n    }\n  }, React.createElement(_components.p, null, React.createElement(_components.img, {\n    src: \"/pinhole_directions.png\",\n    alt: \"Image\"\n  }), \" \")), \"\\n\", React.createElement(_components.p, null, \"Moving onto a richer model, if we rerun the calibration with MrCal's Splined-Stereographic lens model those two plots turn into noise below like we would expect in the ideal case, and this is a result\\nof modeling the lens correctly.\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"1000px\",\n      margin: \"auto\",\n      background: \"white\",\n      display: \"flex\",\n      justifyContent: \"center\"\n    }\n  }, React.createElement(\"img\", {\n    src: \"/spline_magnitudes.png\",\n    alt: \"April Results\",\n    style: {\n      maxWidth: \"50%\",\n      height: \"auto\",\n      marginRight: \"10px\"\n    }\n  }), React.createElement(\"img\", {\n    src: \"/spline_directions.png\",\n    alt: \"Aruco Results\",\n    style: {\n      maxWidth: \"50%\",\n      height: \"auto\"\n    }\n  })), \"\\n\", React.createElement(_components.p, null, \"A benefit of correcting the modeling errors is our reprojection error decreases subsantially. The two histogram's below show the distribution of the residual error. On top is the pinhole model with an RMS reprojection error of 0.7 pixels, and on the bottom is\\nthe spline model with an RMS reprojectin error of less than 0.1 pixels. A concrete example of the spline model significantly helping was in the extrinsic calibration of the fiducial analysis setup. Using the MrCal model compared to the built in realsense intrinsics\\nbrought the translational error of the extrinsics down to 0.25 millimeters from 0.75 millimeters with no additional changes.\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"1000px\",\n      margin: \"auto\",\n      background: \"white\",\n      justifyContent: \"center\"\n    }\n  }, React.createElement(_components.p, null, React.createElement(_components.img, {\n    src: \"/pinhole_histogram.png\",\n    alt: \"Image\"\n  }), \" \", \"\\n\", React.createElement(_components.img, {\n    src: \"/spline_histogram.png\",\n    alt: \"Image\"\n  }), \" \")), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(Divider), \"\\n\", React.createElement(\"br\"), \"\\n\", React.createElement(_components.h2, {\n    id: \"targetless-hand-eye-calibration\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#targetless-hand-eye-calibration\",\n    \"aria-label\": \"targetless hand eye calibration permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Targetless Hand Eye Calibration\"), \"\\n\", React.createElement(_components.p, null, \"Github repository: \", React.createElement(_components.a, {\n    href: \"https://github.com/CarterDiOrio/SfMHandEye\"\n  }, \"https://github.com/CarterDiOrio/SfMHandEye\")), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"800px\",\n      margin: \"auto\",\n      display: \"flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\"\n    }\n  }, React.createElement(\"video\", {\n    autoPlay: true,\n    loop: true,\n    muted: true,\n    playsInline: true,\n    controls: true,\n    style: {\n      maxHeight: \"400px\"\n    }\n  }, React.createElement(\"source\", {\n    src: \"/cloud_cropped.mp4\",\n    type: \"video/mp4\"\n  }))), \"\\n\", React.createElement(_components.p, null, \"As part of a new research thrust for exploring using a highly accurate robot arm, the Mechademic 500, to improve on and make transferable hand eye calibrations, I implemented a targetless hand eye calibration routine. It works by\\nusing Structure From Motion to reconstruct the environment from random camera poses with the robot's motion providing the scale of the scene. Once the environment and camera positions are reconstructed, the environment itself takes the place of the calibration target to\\ngive the trajectory of the camera in the camera frame. The hand eye calibration is then found using Bundle Adjustment. The above video is the 3D point cloud from the SfM reconstruction of the MSR lab environment with the green dots being the registered camera\\nposes. The below video showcases the hand eye calibration by commanding the robot to pivot about the color camera sensor of the camera.\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"800px\",\n      margin: \"auto\",\n      display: \"flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\"\n    }\n  }, React.createElement(\"video\", {\n    autoPlay: true,\n    loop: true,\n    muted: true,\n    playsInline: true,\n    controls: true,\n    style: {\n      maxHeight: \"400px\"\n    }\n  }, React.createElement(\"source\", {\n    src: \"/robot.mp4\",\n    type: \"video/mp4\"\n  }))), \"\\n\", React.createElement(_components.p, null, \"To evaluate the hand eye calibration accuracy I used a similar test to [5]. I had the robot move to poses that observed a ChArUco board. The ChArUco board provided the\\nmovement in the camera frame and then the average translation errors where found by comparing the expected and actual camera motion using the Hand Eye transform. It\\nachieved a mean translational error of 1.7 millimeters and a mean rotational error of 0.37 degrees. To compare this against an industry solution, Zivid an industrial 3D\\ncamera manufacturer, provides a target based hand eye calibration solution and this targetless solution exceeds it in rotational accuracy while falling slightly behind\\nin translation accuracy (See Zivid Results here: https://blog.zivid.com/importance-of-3d-hand-eye-calibration)\"), \"\\n\", React.createElement(\"div\", {\n    style: {\n      maxWidth: \"800px\",\n      margin: \"auto\",\n      display: \"flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\"\n    }\n  }, React.createElement(\"video\", {\n    autoPlay: true,\n    loop: true,\n    muted: true,\n    playsInline: true,\n    controls: true,\n    style: {\n      maxHeight: \"400px\"\n    }\n  }, React.createElement(\"source\", {\n    src: \"/robot_arm_testing.mp4\",\n    type: \"video/mp4\"\n  }))), \"\\n\", React.createElement(_components.h2, {\n    id: \"citations\",\n    style: {\n      position: \"relative\"\n    }\n  }, React.createElement(_components.a, {\n    href: \"#citations\",\n    \"aria-label\": \"citations permalink\",\n    className: \"anchor before\"\n  }, React.createElement(_components.span, {\n    dangerouslySetInnerHTML: {\n      __html: \"<svg aria-hidden=\\\"true\\\" focusable=\\\"false\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg>\"\n    }\n  })), \"Citations\"), \"\\n\", React.createElement(_components.ol, null, \"\\n\", React.createElement(_components.li, null, \"Enebuse I, Ibrahim BKSMK, Foo M, Matharu RS, Ahmed H. Accuracy evaluation of hand-eye calibration techniques for vision-guided robots. PLoS One. 2022;17(10):e0273261. Published 2022 Oct 19. doi:10.1371/journal.pone.027326\"), \"\\n\", React.createElement(_components.li, null, \"H. Tanaka, Y. Sumi and Y. Matsumoto, \\\"A solution to pose ambiguity of visual markers using MoirÃ© patterns,\\\" 2014 IEEE/RSJ International Conference on Intelligent Robots and Systems, Chicago, IL, USA, 2014, pp. 3129-3134, doi: 10.1109/IROS.2014.6942995.\"), \"\\n\", React.createElement(_components.li, null, \"https://mrcal.secretsauce.net/\"), \"\\n\", React.createElement(_components.li, null, \"M. Krogius, A. Haggenmiller and E. Olson, \\\"Flexible Layouts for Fiducial Tags,\\\" 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), Macau, China, 2019, pp. 1898-1903, doi: 10.1109/IROS40897.2019.8967787.\"), \"\\n\", React.createElement(_components.li, null, \"H. Xie, C. -t. Pang, W. -l. Li, Y. -h. Li and Z. -p. Yin, \\\"Hand-eye calibration and its accuracy analysis in robotic grinding,\\\" 2015 IEEE International Conference on Automation Science and Engineering (CASE), Gothenburg, Sweden, 2015, pp. 862-867, doi: 10.1109/CoASE.2015.7294189.\"), \"\\n\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import GATSBY_COMPILED_MDX from \"/home/cdiorio/portfolio/CarterDiOrio.github.io/src/projects/camera-calibration.mdx\";\nimport * as React from \"react\";\nimport Layout from \"../components/layout\";\nimport {MDXProvider} from \"@mdx-js/react\";\nimport * as projectStyles from \"./project.module.css\";\nimport TableOfContents from \"../components/table-of-contents\";\nimport {Card} from \"theme-ui\";\nimport {jsx as _jsx} from \"theme-ui/jsx-runtime\";\nimport {jsxs as _jsxs} from \"theme-ui/jsx-runtime\";\nconst ProjectPost = _ref => {\n  let {data, children} = _ref;\n  return _jsxs(Layout, {\n    children: [!data.mdx.frontmatter.underconstruction && _jsxs(\"div\", {\n      className: projectStyles.projectLayout,\n      children: [_jsx(\"div\", {\n        sx: {\n          paddingRight: \"16px\"\n        },\n        children: _jsxs(Card, {\n          className: projectStyles.tableOfContents,\n          variant: \"tableOfContents\",\n          children: [data.mdx.frontmatter.github && _jsxs(\"p\", {\n            children: [\"Github: \", _jsx(\"a\", {\n              href: data.mdx.frontmatter.github,\n              sx: {\n                color: \"primary\"\n              },\n              children: \"Repository\"\n            }), \" \"]\n          }), _jsx(TableOfContents, {\n            items: data.mdx.tableOfContents.items\n          })]\n        })\n      }), _jsx(\"div\", {\n        children: _jsx(MDXProvider, {\n          children: children\n        })\n      })]\n    }), data.mdx.frontmatter.underconstruction && _jsx(\"div\", {\n      children: _jsx(\"h2\", {\n        children: \"Under Construction. Please check back later for updates\"\n      })\n    })]\n  });\n};\nconst query = \"871196069\";\nexport const Head = _ref2 => {\n  let {data} = _ref2;\n  return _jsx(\"title\", {\n    children: data.mdx.frontmatter.title\n  });\n};\nProjectPost\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(ProjectPost, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\n","import { get } from \"http\";\nimport * as React from \"react\";\nimport { NavLink } from \"theme-ui\";\n\ninterface useIntersectionObserverProps { \n    ids: string[];\n}\n\nconst useIntersectionObserver = ({ ids }: useIntersectionObserverProps) => {\n    const [activeId, setActiveId] = React.useState(``);\n    \n    React.useEffect(() => {\n        const callback: IntersectionObserverCallback = (entires) => {\n            entires.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    const id = entry.target.getAttribute('id');\n                    setActiveId(id!);\n                }\n            })\n        };\n\n        //find each element by id\n        const elements = ids.map((id) => document.getElementById(id));\n        \n        //create an observer\n        const observer = new IntersectionObserver(callback, {\n            rootMargin: `0% 0% -80% 0%`\n        });\n\n        //observe each element\n        elements.forEach((element) => observer.observe(element!));\n\n        return () => observer.disconnect();\n    }, []);\n\n    return activeId;\n}\n\nconst getIds = (items: any) => {\n    return items.reduce((acc: any, item: any) => {\n        if (item.url) {\n            acc.push(item.url.slice(1));\n        }\n        if (item.items) {\n            acc.push(...getIds(item.items));\n        }\n        return acc;\n    }, []);\n} \n\nconst TocItem = ({ items, activeId, depth }: any) => {\n    console.log(items);\n    const padding = depth == 0 ? \"16px\" : \"16px\";\n    return (\n        <ul style={{\"listStyleType\": \"none\", \"paddingLeft\": padding}}>\n            {\n                items.map((item: any) => {\n                    const variant = item.url === `#${activeId}` ? \"tableOfContentsActive\" : \"tableOfContents\";\n                    return (\n                        <li key={item.url}>\n                            <NavLink href={item.url} variant={`${variant}`} style={{ fontSize: `${18 - 3*depth}px`, opacity: `${1 - 0.2*depth}` }}>\n                                {item.title}\n                            </NavLink>\n                            {item.items && \n                                <TocItem items={item.items} activeId={activeId} depth={depth+1} />\n                            }\n                        </li>                    \n                    )\n                })\n            }\n        </ul>\n    )\n}\n\nconst TableOfContents = ({ items }: any) => {\n    const ids = getIds(items);\n    const activeId = useIntersectionObserver({ ids });\n    return (\n        <>\n            <h2>Contents</h2>\n            <TocItem items={items[0].items} activeId={activeId} depth={0} />\n        </>\n    )\n};\n\nexport default TableOfContents;","// extracted by mini-css-extract-plugin\nexport var projectLayout = \"project-module--projectLayout--0a8d9\";\nexport var tableOfContents = \"project-module--tableOfContents--da931\";"],"names":["_createMdxContent","props","_components","Object","assign","h1","a","span","h2","p","h3","img","ol","li","_provideComponents","components","React","id","style","position","href","className","dangerouslySetInnerHTML","__html","Divider","maxWidth","margin","autoPlay","loop","muted","playsInline","controls","maxHeight","src","type","alt","display","justifyContent","alignItems","background","height","marginRight","wrapper","MDXLayout","ProjectPost","_ref","data","children","_jsxs","Layout","mdx","frontmatter","underconstruction","projectStyles","_jsx","sx","paddingRight","Card","variant","github","color","TableOfContents","items","tableOfContents","MDXProvider","Head","_ref2","title","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","getIds","reduce","acc","item","url","push","slice","TocItem","activeId","depth","console","log","map","NavLink","fontSize","opacity","_ref3","ids","setActiveId","elements","document","getElementById","observer","IntersectionObserver","entires","forEach","entry","isIntersecting","target","getAttribute","rootMargin","element","observe","disconnect","useIntersectionObserver","projectLayout"],"sourceRoot":""}